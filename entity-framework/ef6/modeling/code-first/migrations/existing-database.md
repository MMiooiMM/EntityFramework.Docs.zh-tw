---
title: 與現有的資料庫-EF6 code First 移轉
author: divega
ms.date: 2016-10-23
ms.assetid: f0cc4f93-67dd-4664-9753-0a9f913814db
ms.openlocfilehash: 06aabf3f57ca451f4d9cba469f6de40fd9aa8f23
ms.sourcegitcommit: dadee5905ada9ecdbae28363a682950383ce3e10
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/27/2018
ms.locfileid: "42998193"
---
# <a name="code-first-migrations-with-an-existing-database"></a><span data-ttu-id="ce798-102">與現有的資料庫的 code First 移轉</span><span class="sxs-lookup"><span data-stu-id="ce798-102">Code First Migrations with an existing database</span></span>
> [!NOTE]
> <span data-ttu-id="ce798-103">**EF4.3 及更新版本僅**-功能、 Api、 Entity Framework 4.1 中導入等本頁所述。</span><span class="sxs-lookup"><span data-stu-id="ce798-103">**EF4.3 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 4.1.</span></span> <span data-ttu-id="ce798-104">如果您使用的是較早版本，則不適用部分或全部的資訊。</span><span class="sxs-lookup"><span data-stu-id="ce798-104">If you are using an earlier version, some or all of the information does not apply.</span></span>

<span data-ttu-id="ce798-105">本文章涵蓋使用現有的資料庫，一個不由 Entity Framework Code First 移轉。</span><span class="sxs-lookup"><span data-stu-id="ce798-105">This article covers using Code First Migrations with an existing database, one that wasn’t created by Entity Framework.</span></span>

> [!NOTE]
> <span data-ttu-id="ce798-106">本文假設您知道如何在基本案例中使用 Code First 移轉。</span><span class="sxs-lookup"><span data-stu-id="ce798-106">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="ce798-107">如果不這麼做，則您將需要閱讀[Code First 移轉](~/ef6/modeling/code-first/migrations/index.md)再繼續進行。</span><span class="sxs-lookup"><span data-stu-id="ce798-107">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="screencasts"></a><span data-ttu-id="ce798-108">螢幕錄製影片</span><span class="sxs-lookup"><span data-stu-id="ce798-108">Screencasts</span></span>

<span data-ttu-id="ce798-109">如果您想而不是觀看螢幕錄製影片比閱讀這篇文章，下列兩個影片涵蓋這份文件相同的內容。</span><span class="sxs-lookup"><span data-stu-id="ce798-109">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="ce798-110">影片的一個:"移轉-在幕後"</span><span class="sxs-lookup"><span data-stu-id="ce798-110">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="ce798-111">[這段螢幕錄製影片](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood)涵蓋如何移轉追蹤，並使用模型的相關資訊，來偵測模型變更。</span><span class="sxs-lookup"><span data-stu-id="ce798-111">[This screencast](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---existing-databases"></a><span data-ttu-id="ce798-112">影片的兩個: 「 移轉-現有資料庫 」</span><span class="sxs-lookup"><span data-stu-id="ce798-112">Video Two: "Migrations - Existing Databases"</span></span>

<span data-ttu-id="ce798-113">在上一段影片中，從概念上建置[這段螢幕錄製影片](http://channel9.msdn.com/blogs/ef/migrations-existing-databases)說明如何啟用及使用現有的資料庫中的移轉。</span><span class="sxs-lookup"><span data-stu-id="ce798-113">Building on the concepts from the previous video, [this screencast](http://channel9.msdn.com/blogs/ef/migrations-existing-databases) covers how to enable and use migrations with an existing database.</span></span>

## <a name="step-1-create-a-model"></a><span data-ttu-id="ce798-114">步驟 1： 建立模型</span><span class="sxs-lookup"><span data-stu-id="ce798-114">Step 1: Create a model</span></span>

<span data-ttu-id="ce798-115">您的第一個步驟會建立您的現有資料庫為目標的 Code First 模型。</span><span class="sxs-lookup"><span data-stu-id="ce798-115">Your first step will be to create a Code First model that targets your existing database.</span></span> <span data-ttu-id="ce798-116">[Code First 至現有的資料庫](~/ef6/modeling/code-first/workflows/existing-database.md)主題提供如何執行這項操作的詳細指導方針。</span><span class="sxs-lookup"><span data-stu-id="ce798-116">The [Code First to an Existing Database](~/ef6/modeling/code-first/workflows/existing-database.md) topic provides detailed guidance on how to do this.</span></span>

>[!NOTE]
> <span data-ttu-id="ce798-117">請務必遵循本主題中步驟的其餘部分之前對您的模型會需要變更資料庫結構描述進行任何變更。</span><span class="sxs-lookup"><span data-stu-id="ce798-117">It is important to follow the rest of the steps in this topic before making any changes to your model that would require changes to the database schema.</span></span> <span data-ttu-id="ce798-118">下列步驟需要為同步模型與資料庫結構描述。</span><span class="sxs-lookup"><span data-stu-id="ce798-118">The following steps require the model to be in-sync with the database schema.</span></span>

## <a name="step-2-enable-migrations"></a><span data-ttu-id="ce798-119">步驟 2： 啟用移轉</span><span class="sxs-lookup"><span data-stu-id="ce798-119">Step 2: Enable Migrations</span></span>

<span data-ttu-id="ce798-120">下一個步驟是啟用移轉。</span><span class="sxs-lookup"><span data-stu-id="ce798-120">The next step is to enable migrations.</span></span> <span data-ttu-id="ce798-121">您可以藉由執行**Enable-migrations**命令在套件管理員主控台。</span><span class="sxs-lookup"><span data-stu-id="ce798-121">You can do this by running the **Enable-Migrations** command in Package Manager Console.</span></span>

<span data-ttu-id="ce798-122">此命令會呼叫移轉，在方案中建立資料夾，並將單一類別稱為 「 設定其內部放置。</span><span class="sxs-lookup"><span data-stu-id="ce798-122">This command will create a folder in your solution called Migrations, and put a single class inside it called Configuration.</span></span> <span data-ttu-id="ce798-123">設定類別可讓您設定移轉應用程式，您可以深入了解它在[Code First 移轉](~/ef6/modeling/code-first/migrations/index.md)主題。</span><span class="sxs-lookup"><span data-stu-id="ce798-123">The Configuration class is where you configure migrations for your application, you can find out more about it in the [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) topic.</span></span>

## <a name="step-3-add-an-initial-migration"></a><span data-ttu-id="ce798-124">步驟 3： 新增初始移轉</span><span class="sxs-lookup"><span data-stu-id="ce798-124">Step 3: Add an initial migration</span></span>

<span data-ttu-id="ce798-125">一旦移轉已建立並套用至本機資料庫，您也可以在套用這些變更至其他資料庫。</span><span class="sxs-lookup"><span data-stu-id="ce798-125">Once migrations have been created and applied to the local database you may also want to apply these changes to other databases.</span></span> <span data-ttu-id="ce798-126">比方說，您的本機資料庫可能是測試資料庫和您最終需要也將變更套用至生產環境資料庫和/或其他開發人員測試資料庫。</span><span class="sxs-lookup"><span data-stu-id="ce798-126">For example, your local database may be a test database and you may ultimately want to also apply the changes to a production database and/or other developers test databases.</span></span> <span data-ttu-id="ce798-127">有兩個選項，此步驟中，您就應該挑選一個取決是空的或目前符合的本機資料庫結構描述的任何其他的資料庫結構描述。</span><span class="sxs-lookup"><span data-stu-id="ce798-127">There are two options for this step and the one you should pick depends whether or not the schema of any other databases is empty or currently matches the schema of the local database.</span></span>

-   <span data-ttu-id="ce798-128">**選項 1： 使用現有的結構描述做為起點。**</span><span class="sxs-lookup"><span data-stu-id="ce798-128">**Option One: Use existing schema as starting point.**</span></span> <span data-ttu-id="ce798-129">其他移轉將會套用至未來的資料庫會有相同的結構描述，因為目前有您的本機資料庫時，您應該使用這種方法。</span><span class="sxs-lookup"><span data-stu-id="ce798-129">You should use this approach when other databases that migrations will be applied to in the future will have the same schema as your local database currently has.</span></span> <span data-ttu-id="ce798-130">例如，您可能會以此如果您的本機測試資料庫目前符合 v1 的生產資料庫，而且您稍後會套用這些移轉，以更新您的生產資料庫為 v2。</span><span class="sxs-lookup"><span data-stu-id="ce798-130">For example, you might use this if your local test database currently matches v1 of your production database and you will later apply these migrations to update your production database to v2.</span></span>
-   <span data-ttu-id="ce798-131">**選項 2： 使用空的資料庫做為起點。**</span><span class="sxs-lookup"><span data-stu-id="ce798-131">**Option Two: Use empty database as starting point.**</span></span> <span data-ttu-id="ce798-132">其他移轉將會套用至未來的資料庫是空的 （或尚不存在） 時，您應該使用這種方法。</span><span class="sxs-lookup"><span data-stu-id="ce798-132">You should use this approach when other databases that migrations will be applied to in the future are empty (or do not exist yet).</span></span> <span data-ttu-id="ce798-133">例如，您可能會以此如果您開始開發您的應用程式使用的測試資料庫，但不使用移轉，您將會稍後想要從頭開始建立實際執行的資料庫。</span><span class="sxs-lookup"><span data-stu-id="ce798-133">For example, you might use this if you started developing your application using a test database but without using migrations and you will later want to create a production database from scratch.</span></span>

### <a name="option-one-use-existing-schema-as-a-starting-point"></a><span data-ttu-id="ce798-134">選項 1： 使用現有的結構描述做為起點</span><span class="sxs-lookup"><span data-stu-id="ce798-134">Option One: Use existing schema as a starting point</span></span>

<span data-ttu-id="ce798-135">Code First 移轉使用快照集儲存在最新的移轉中的模型來偵測模型的變更 (您可以找到詳細說明這[小組環境中的 Code First 移轉](~/ef6/modeling/code-first/migrations/teams.md))。</span><span class="sxs-lookup"><span data-stu-id="ce798-135">Code First Migrations uses a snapshot of the model stored in the most recent migration to detect changes to the model (you can find detailed information about this in [Code First Migrations in Team Environments](~/ef6/modeling/code-first/migrations/teams.md)).</span></span> <span data-ttu-id="ce798-136">因為我們假設資料庫已經有目前模型的結構描述，我們將會產生空的 （無作業） 移轉具有目前的模型，當做快照集。</span><span class="sxs-lookup"><span data-stu-id="ce798-136">Since we are going to assume that databases already have the schema of the current model, we will generate an empty (no-op) migration that has the current model as a snapshot.</span></span>

1.  <span data-ttu-id="ce798-137">執行**Add-migration 為 InitialCreate – IgnoreChanges**命令在套件管理員主控台。</span><span class="sxs-lookup"><span data-stu-id="ce798-137">Run the **Add-Migration InitialCreate –IgnoreChanges** command in Package Manager Console.</span></span> <span data-ttu-id="ce798-138">這與目前模型中建立空白的移轉，當做快照集。</span><span class="sxs-lookup"><span data-stu-id="ce798-138">This creates an empty migration with the current model as a snapshot.</span></span>
2.  <span data-ttu-id="ce798-139">執行**Update-database**命令在套件管理員主控台。</span><span class="sxs-lookup"><span data-stu-id="ce798-139">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="ce798-140">這會套用為 InitialCreate 移轉至資料庫。</span><span class="sxs-lookup"><span data-stu-id="ce798-140">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="ce798-141">在實際移轉未包含任何變更，因為它將只會新增至一個資料列\_ \_MigrationsHistory 資料表表示已套用此移轉。</span><span class="sxs-lookup"><span data-stu-id="ce798-141">Since the actual migration doesn’t contain any changes, it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>

### <a name="option-two-use-empty-database-as-a-starting-point"></a><span data-ttu-id="ce798-142">選項 2： 使用做為起點的空白資料庫</span><span class="sxs-lookup"><span data-stu-id="ce798-142">Option Two: Use empty database as a starting point</span></span>

<span data-ttu-id="ce798-143">在此案例中，我們必須要能夠從頭 – 包括已出現在本機資料庫中的資料表建立整個資料庫的移轉。</span><span class="sxs-lookup"><span data-stu-id="ce798-143">In this scenario we need Migrations to be able to create the entire database from scratch – including the tables that are already present in our local database.</span></span> <span data-ttu-id="ce798-144">我們將產生的狀態為 InitialCreate 移轉，其中包含建立現有的結構描述的邏輯。</span><span class="sxs-lookup"><span data-stu-id="ce798-144">We’re going to generate an InitialCreate migration that includes logic to create the existing schema.</span></span> <span data-ttu-id="ce798-145">接著，我們要讓我們看起來像是已套用此移轉現有的資料庫。</span><span class="sxs-lookup"><span data-stu-id="ce798-145">We’ll then make our existing database look like this migration has already been applied.</span></span>

1.  <span data-ttu-id="ce798-146">執行**Add-migration 為 InitialCreate**命令在套件管理員主控台。</span><span class="sxs-lookup"><span data-stu-id="ce798-146">Run the **Add-Migration InitialCreate** command in Package Manager Console.</span></span> <span data-ttu-id="ce798-147">這會建立建立現有的結構描述移轉。</span><span class="sxs-lookup"><span data-stu-id="ce798-147">This creates a migration to create the existing schema.</span></span>
2.  <span data-ttu-id="ce798-148">新建立的移轉最多方法中的所有程式碼註解化。</span><span class="sxs-lookup"><span data-stu-id="ce798-148">Comment out all code in the Up method of the newly created migration.</span></span> <span data-ttu-id="ce798-149">這可讓我們 '' 將移轉套用至本機資料庫但不會嘗試重新建立所有資料表等已存在。</span><span class="sxs-lookup"><span data-stu-id="ce798-149">This will allow us to ‘apply’ the migration to the local database without trying to recreate all the tables etc. that already exist.</span></span>
3.  <span data-ttu-id="ce798-150">執行**Update-database**命令在套件管理員主控台。</span><span class="sxs-lookup"><span data-stu-id="ce798-150">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="ce798-151">這會套用為 InitialCreate 移轉至資料庫。</span><span class="sxs-lookup"><span data-stu-id="ce798-151">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="ce798-152">由於在實際移轉未包含任何變更 （因為我們暫時標記為註解方式），它將只會新增至一個資料列\_ \_MigrationsHistory 資料表表示已套用此移轉。</span><span class="sxs-lookup"><span data-stu-id="ce798-152">Since the actual migration doesn’t contain any changes (because we temporarily commented them out), it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>
4.  <span data-ttu-id="ce798-153">取消註解中的總方法的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ce798-153">Un-comment the code in the Up method.</span></span> <span data-ttu-id="ce798-154">這表示，當此移轉套用至未來的資料庫，在本機資料庫中已經有結構描述就會建立藉由移轉。</span><span class="sxs-lookup"><span data-stu-id="ce798-154">This means that when this migration is applied to future databases, the schema that already existed in the local database will be created by migrations.</span></span>

## <a name="things-to-be-aware-of"></a><span data-ttu-id="ce798-155">要注意的事項</span><span class="sxs-lookup"><span data-stu-id="ce798-155">Things to be aware of</span></span>

<span data-ttu-id="ce798-156">有幾件事，您需要使用移轉對現有的資料庫時應該注意。</span><span class="sxs-lookup"><span data-stu-id="ce798-156">There are a few things you need to be aware of when using Migrations against an existing database.</span></span>

### <a name="defaultcalculated-names-may-not-match-existing-schema"></a><span data-ttu-id="ce798-157">預設/計算的名稱可能不符合現有的結構描述</span><span class="sxs-lookup"><span data-stu-id="ce798-157">Default/calculated names may not match existing schema</span></span>

<span data-ttu-id="ce798-158">移轉會在它則移轉時，明確指定資料行和資料表的名稱。</span><span class="sxs-lookup"><span data-stu-id="ce798-158">Migrations explicitly specifies names for columns and tables when it scaffolds a migrations.</span></span> <span data-ttu-id="ce798-159">不過，有其他資料庫物件時套用移轉，移轉會計算的預設名稱。</span><span class="sxs-lookup"><span data-stu-id="ce798-159">However, there are other database objects that Migrations calculates a default name for when applying the migrations.</span></span> <span data-ttu-id="ce798-160">這包括索引和 foreign key 條件約束。</span><span class="sxs-lookup"><span data-stu-id="ce798-160">This includes indexes and foreign key constraints.</span></span> <span data-ttu-id="ce798-161">當目標設為現有的結構描述，這些導出的名稱可能不符合實際存在於您的資料庫。</span><span class="sxs-lookup"><span data-stu-id="ce798-161">When targeting an existing schema, these calculated names may not match what actually exists in your database.</span></span>

<span data-ttu-id="ce798-162">當您需要特別注意這一點時，以下是一些範例：</span><span class="sxs-lookup"><span data-stu-id="ce798-162">Here are some examples of when you need to be aware of this:</span></span>

<span data-ttu-id="ce798-163">**如果您使用 '一個選項： 使用現有的結構描述做為起點' 從步驟 3:**</span><span class="sxs-lookup"><span data-stu-id="ce798-163">**If you used ‘Option One: Use existing schema as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="ce798-164">如果您在模型中的未來變更需要變更或卸除其中一個名稱不同的資料庫物件，您必須修改 scaffold 的移轉至指定的正確名稱。</span><span class="sxs-lookup"><span data-stu-id="ce798-164">If future changes in your model require changing or dropping one of the database objects that is named differently, you will need to modify the scaffolded migration to specify the correct name.</span></span> <span data-ttu-id="ce798-165">移轉 Api 有選擇性的 Name 參數，可讓您執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="ce798-165">The Migrations APIs have an optional Name parameter that allows you to do this.</span></span>
    <span data-ttu-id="ce798-166">例如，您現有的結構描述可能有 BlogId 外部索引鍵資料行具有名為 IndexFk 索引的 Post 資料表\_BlogId。</span><span class="sxs-lookup"><span data-stu-id="ce798-166">For example, your existing schema may have a Post table with a BlogId foreign key column that has an index named IndexFk\_BlogId.</span></span> <span data-ttu-id="ce798-167">不過，根據預設移轉預期這個索引命名為 IX\_BlogId。</span><span class="sxs-lookup"><span data-stu-id="ce798-167">However, by default Migrations would expect this index to be named IX\_BlogId.</span></span> <span data-ttu-id="ce798-168">如果您變更您的模型會導致卸除此索引時，您必須修改包含 scaffold 的 DropIndex 呼叫，可指定 IndexFk\_BlogId 名稱。</span><span class="sxs-lookup"><span data-stu-id="ce798-168">If you make a change to your model that results in dropping this index, you will need to modify the scaffolded DropIndex call to specify the IndexFk\_BlogId name.</span></span>

<span data-ttu-id="ce798-169">**如果您使用 '兩個選項： 使用空的資料庫做為起點' 從步驟 3:**</span><span class="sxs-lookup"><span data-stu-id="ce798-169">**If you used ‘Option Two: Use empty database as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="ce798-170">嘗試對您的本機資料庫執行初始移轉 （也就是空的資料庫即還原） 的清單方法可能會失敗，因為移轉將會嘗試卸除索引和 foreign key 條件約束使用不正確的名稱。</span><span class="sxs-lookup"><span data-stu-id="ce798-170">Trying to run the Down method of the initial migration (that is, reverting to an empty database) against your local database may fail because Migrations will try to drop indexes and foreign key constraints using the incorrect names.</span></span> <span data-ttu-id="ce798-171">因為其他資料庫會使用初始移轉的總方法的從頭開始建立，這只會影響您的本機資料庫。</span><span class="sxs-lookup"><span data-stu-id="ce798-171">This will only affect your local database since other databases will be created from scratch using the Up method of the initial migration.</span></span>
    <span data-ttu-id="ce798-172">如果您想要將現有本機資料庫降級至空白的狀態是最簡單的方式手動執行此動作，藉由卸除資料庫，或卸除所有資料表。</span><span class="sxs-lookup"><span data-stu-id="ce798-172">If you want to downgrade your existing local database to an empty state it is easiest to do this manually, either by dropping the database or dropping all the tables.</span></span> <span data-ttu-id="ce798-173">之後會重新建立所有資料庫物件，預設名稱與此初始降級，因此這個問題不會提供本身一次。</span><span class="sxs-lookup"><span data-stu-id="ce798-173">After this initial downgrade all database objects will be recreated with the default names, so this issue will not present itself again.</span></span>
-   <span data-ttu-id="ce798-174">如果您在模型中的未來變更需要變更或卸除其中一個名稱不同的資料庫物件，這將無法運作對您現有的本機資料庫 – 由於名稱不符合預設值。</span><span class="sxs-lookup"><span data-stu-id="ce798-174">If future changes in your model require changing or dropping one of the database objects that is named differently, this will not work against your existing local database – since the names won’t match the defaults.</span></span> <span data-ttu-id="ce798-175">不過，它就能對資料庫所建立 '從頭'，因為它們會使用移轉所選擇的預設名稱。</span><span class="sxs-lookup"><span data-stu-id="ce798-175">However, it will work against databases that were created ‘from scratch’ since they will have used the default names chosen by Migrations.</span></span>
    <span data-ttu-id="ce798-176">您可以手動進行這些變更，在您本機的現有資料庫，或考慮讓移轉重新建立您的資料庫，從零開始 – 它會在其他電腦上。</span><span class="sxs-lookup"><span data-stu-id="ce798-176">You could either make these changes manually on your local existing database, or consider having Migrations recreate your database from scratch – as it will on other machines.</span></span>
-   <span data-ttu-id="ce798-177">使用初始移轉的方法所建立的資料庫可能稍有不同的本機資料庫自索引的導出的預設名稱，並將使用 foreign key 條件約束。</span><span class="sxs-lookup"><span data-stu-id="ce798-177">Databases created using the Up method of your initial migration may differ slightly from the local database since the calculated default names for indexes and foreign key constraints will be used.</span></span> <span data-ttu-id="ce798-178">您也會有額外的索引，移轉將會建立外部索引鍵資料行上索引根據預設，這可能不是原始的本機資料庫中的案例。</span><span class="sxs-lookup"><span data-stu-id="ce798-178">You may also end up with extra indexes as Migrations will create indexes on foreign key columns by default – this may not have been the case in your original local database.</span></span>

### <a name="not-all-database-objects-are-represented-in-the-model"></a><span data-ttu-id="ce798-179">並非所有的資料庫物件都代表在模型中</span><span class="sxs-lookup"><span data-stu-id="ce798-179">Not all database objects are represented in the model</span></span>

<span data-ttu-id="ce798-180">藉由移轉不會處理不屬於您的模型的資料庫物件。</span><span class="sxs-lookup"><span data-stu-id="ce798-180">Database objects that are not part of your model will not be handled by Migrations.</span></span> <span data-ttu-id="ce798-181">這可能包括檢視、 預存程序、 權限、 資料表，並不屬於您的模型、 額外的索引等等。</span><span class="sxs-lookup"><span data-stu-id="ce798-181">This can include views, stored procedures, permissions, tables that are not part of your model, additional indexes, etc.</span></span>

<span data-ttu-id="ce798-182">當您需要特別注意這一點時，以下是一些範例：</span><span class="sxs-lookup"><span data-stu-id="ce798-182">Here are some examples of when you need to be aware of this:</span></span>

-   <span data-ttu-id="ce798-183">不論選擇您已選擇在步驟 3，如果您在模型中的未來變更需要變更或卸除這些額外的物件移轉不會知道要進行這些變更。</span><span class="sxs-lookup"><span data-stu-id="ce798-183">Regardless of the option you chose in ‘Step 3’, if future changes in your model require changing or dropping these additional objects Migrations will not know to make these changes.</span></span> <span data-ttu-id="ce798-184">比方說，如果您卸除的資料行有其他的索引，移轉將不會知道要卸除索引。</span><span class="sxs-lookup"><span data-stu-id="ce798-184">For example, if you drop a column that has an additional index on it, Migrations will not know to drop the index.</span></span> <span data-ttu-id="ce798-185">您必須手動加入至包含 scaffold 的移轉。</span><span class="sxs-lookup"><span data-stu-id="ce798-185">You will need to manually add this to the scaffolded Migration.</span></span>
-   <span data-ttu-id="ce798-186">如果您使用 ' 兩個選項： 使用空的資料庫做為起點 '，這些額外的物件將不會建立初始移轉的總方法。</span><span class="sxs-lookup"><span data-stu-id="ce798-186">If you used ‘Option Two: Use empty database as a starting point’, these additional objects will not be created by the Up method of your initial migration.</span></span>
    <span data-ttu-id="ce798-187">您可以修改向上，而在您想除如果負責這些其他物件的方法。</span><span class="sxs-lookup"><span data-stu-id="ce798-187">You can modify the Up and Down methods to take care of these additional objects if you wish.</span></span> <span data-ttu-id="ce798-188">您可以使用原生不支援移轉 API – 例如檢視表-中的物件[Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx)方法來執行原始的 SQL 來建立/卸除它們。</span><span class="sxs-lookup"><span data-stu-id="ce798-188">For objects that are not natively supported in the Migrations API – such as views – you can use the [Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) method to run raw SQL to create/drop them.</span></span>
