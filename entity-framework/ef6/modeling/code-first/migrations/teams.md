---
title: 在小組環境-EF6 code First 移轉
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: f5216a80928625040d6719f0e97ae786e5e33e05
ms.sourcegitcommit: 2b787009fd5be5627f1189ee396e708cd130e07b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/13/2018
ms.locfileid: "45490502"
---
# <a name="code-first-migrations-in-team-environments"></a><span data-ttu-id="bae24-102">在小組環境中的 code First 移轉</span><span class="sxs-lookup"><span data-stu-id="bae24-102">Code First Migrations in Team Environments</span></span>
> [!NOTE]
> <span data-ttu-id="bae24-103">本文假設您知道如何在基本案例中使用 Code First 移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-103">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="bae24-104">如果不這麼做，則您將需要閱讀[Code First 移轉](~/ef6/modeling/code-first/migrations/index.md)再繼續進行。</span><span class="sxs-lookup"><span data-stu-id="bae24-104">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a><span data-ttu-id="bae24-105">喝杯咖啡，您必須閱讀這整篇文章</span><span class="sxs-lookup"><span data-stu-id="bae24-105">Grab a coffee, you need to read this whole article</span></span>

<span data-ttu-id="bae24-106">在小組環境中的問題是大部分周圍合併時兩位開發人員在其本機程式碼基底中產生移轉的移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-106">The issues in team environments are mostly around merging migrations when two developers have generated migrations in their local code base.</span></span> <span data-ttu-id="bae24-107">雖然要面對的這些步驟很簡單，它們需要您已充分了解移轉的運作方式。</span><span class="sxs-lookup"><span data-stu-id="bae24-107">While the steps to solve these are pretty simple, they require you to have a solid understanding of how migrations works.</span></span> <span data-ttu-id="bae24-108">請不要只請直接跳到結尾 – 花點時間閱讀整個的文章，以確保您成功。</span><span class="sxs-lookup"><span data-stu-id="bae24-108">Please don’t just skip ahead to the end – take the time to read the whole article to ensure you are successful.</span></span>

## <a name="some-general-guidelines"></a><span data-ttu-id="bae24-109">一些一般指導方針</span><span class="sxs-lookup"><span data-stu-id="bae24-109">Some general guidelines</span></span>

<span data-ttu-id="bae24-110">我們深入探討如何管理合併多個開發人員所產生的移轉之前，以下是一些一般指導方針來設定您準備好邁向成功。</span><span class="sxs-lookup"><span data-stu-id="bae24-110">Before we dig into how to manage merging migrations generated by multiple developers, here are some general guidelines to set you up for success.</span></span>

### <a name="each-team-member-should-have-a-local-development-database"></a><span data-ttu-id="bae24-111">每個小組成員應該具有本機開發資料庫</span><span class="sxs-lookup"><span data-stu-id="bae24-111">Each team member should have a local development database</span></span>

<span data-ttu-id="bae24-112">移轉會使用 **\_ \_MigrationsHistory**儲存哪些移轉已套用至資料庫資料表。</span><span class="sxs-lookup"><span data-stu-id="bae24-112">Migrations uses the **\_\_MigrationsHistory** table to store what migrations have been applied to the database.</span></span> <span data-ttu-id="bae24-113">如果您有多個開發人員嘗試以相同的資料庫為目標時產生不同的移轉 (並因此分享 **\_ \_MigrationsHistory**資料表) 移轉前往亂成一團了。</span><span class="sxs-lookup"><span data-stu-id="bae24-113">If you have multiple developers generating different migrations while trying to target the same database (and thus share a **\_\_MigrationsHistory** table) migrations is going to get very confused.</span></span>

<span data-ttu-id="bae24-114">當然，如果您的小組成員不會產生移轉，是讓它們共用中央開發資料庫沒有問題。</span><span class="sxs-lookup"><span data-stu-id="bae24-114">Of course, if you have team members that aren’t generating migrations, there is no problem having them share a central development database.</span></span>

### <a name="avoid-automatic-migrations"></a><span data-ttu-id="bae24-115">避免自動移轉</span><span class="sxs-lookup"><span data-stu-id="bae24-115">Avoid automatic migrations</span></span>

<span data-ttu-id="bae24-116">重點是，自動移轉一開始看起來沒有問題，在小組環境中，但實際上只是不會使用。</span><span class="sxs-lookup"><span data-stu-id="bae24-116">The bottom line is that automatic migrations initially look good in team environments, but in reality they just don’t work.</span></span> <span data-ttu-id="bae24-117">如果您想要知道為什麼，繼續閱讀 – 如果沒有，則您可以跳到下一節。</span><span class="sxs-lookup"><span data-stu-id="bae24-117">If you want to know why, keep reading – if not, then you can skip to the next section.</span></span>

<span data-ttu-id="bae24-118">自動移轉，可讓您有資料庫結構描述更新，以符合目前的模型，而不需要產生程式碼檔案 （程式碼型的移轉）。</span><span class="sxs-lookup"><span data-stu-id="bae24-118">Automatic migrations allows you to have your database schema updated to match the current model without the need to generate code files (code-based migrations).</span></span> <span data-ttu-id="bae24-119">在小組環境中，如果您只會使用它們，並永遠不會產生任何程式碼為基礎的移轉自動移轉會非常正常運作。</span><span class="sxs-lookup"><span data-stu-id="bae24-119">Automatic migrations would work very well in a team environment if you only ever used them and never generated any code-based migrations.</span></span> <span data-ttu-id="bae24-120">問題在於，自動移轉限制，且未處理的一些作業屬性/資料行重新命名、 將資料移到另一個資料表，等等。若要處理這些案例，您最後會產生程式碼型的移轉 （和編輯的 scaffold 程式碼） 的混合之間都由自動移轉的變更。</span><span class="sxs-lookup"><span data-stu-id="bae24-120">The problem is that automatic migrations are limited and don’t handle a number of operations – property/column renames, moving data to another table, etc. To handle these scenarios you end up generating code-based migrations (and editing the scaffolded code) that are mixed in between changes that are handled by automatic migrations.</span></span> <span data-ttu-id="bae24-121">這對它幾乎不可能將變更合併，當兩位開發人員簽入移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-121">This makes it near on impossible to merge changes when two developers check in migrations.</span></span>

## <a name="screencasts"></a><span data-ttu-id="bae24-122">螢幕錄製影片</span><span class="sxs-lookup"><span data-stu-id="bae24-122">Screencasts</span></span>

<span data-ttu-id="bae24-123">如果您想而不是觀看螢幕錄製影片比閱讀這篇文章，下列兩個影片涵蓋這份文件相同的內容。</span><span class="sxs-lookup"><span data-stu-id="bae24-123">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="bae24-124">影片的一個:"移轉-在幕後"</span><span class="sxs-lookup"><span data-stu-id="bae24-124">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="bae24-125">[這段螢幕錄製影片](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood)涵蓋如何移轉追蹤，並使用模型的相關資訊，來偵測模型變更。</span><span class="sxs-lookup"><span data-stu-id="bae24-125">[This screencast](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---team-environments"></a><span data-ttu-id="bae24-126">影片的兩個: 「 移轉-小組環境 」</span><span class="sxs-lookup"><span data-stu-id="bae24-126">Video Two: "Migrations - Team Environments"</span></span>

<span data-ttu-id="bae24-127">在上一段影片中，從概念上建置[這段螢幕錄製影片](http://channel9.msdn.com/blogs/ef/migrations-team-environments)涵蓋了在小組環境，以及如何解決這些問題發生的問題。</span><span class="sxs-lookup"><span data-stu-id="bae24-127">Building on the concepts from the previous video, [this screencast](http://channel9.msdn.com/blogs/ef/migrations-team-environments) covers the issues that arise in a team environment and how to solve them.</span></span>

## <a name="understanding-how-migrations-works"></a><span data-ttu-id="bae24-128">了解移轉的運作方式</span><span class="sxs-lookup"><span data-stu-id="bae24-128">Understanding how migrations works</span></span>

<span data-ttu-id="bae24-129">要成功地在小組環境中使用移轉的索引鍵是基本了解如何移轉追蹤，並使用有關模型的資訊來偵測模型的變更。</span><span class="sxs-lookup"><span data-stu-id="bae24-129">The key to successfully using migrations in a team environment is a basic understanding how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="the-first-migration"></a><span data-ttu-id="bae24-130">第一次移轉</span><span class="sxs-lookup"><span data-stu-id="bae24-130">The first migration</span></span>

<span data-ttu-id="bae24-131">當您第一次移轉新增至您的專案時，您會執行類似**Add-migration 第一個**在套件管理員主控台。</span><span class="sxs-lookup"><span data-stu-id="bae24-131">When you add the first migration to your project, you run something like **Add-Migration First** in Package Manager Console.</span></span> <span data-ttu-id="bae24-132">下圖是此命令會執行的高層級步驟。</span><span class="sxs-lookup"><span data-stu-id="bae24-132">The high level steps that this command performs are pictured below.</span></span>

![第一次移轉](~/ef6/media/firstmigration.png)

<span data-ttu-id="bae24-134">目前的模型會計算從您的程式碼 (1)。</span><span class="sxs-lookup"><span data-stu-id="bae24-134">The current model is calculated from your code (1).</span></span> <span data-ttu-id="bae24-135">模型的差異 (2) 然後計算所需的資料庫物件，因為這是第一次移轉模型不同只會使用空的模型進行比較。</span><span class="sxs-lookup"><span data-stu-id="bae24-135">The required database objects are then calculated by the model differ (2) – since this is the first migration the model differ just uses an empty model for the comparison.</span></span> <span data-ttu-id="bae24-136">必要的變更會傳遞至程式碼產生器，以建置必要的移轉程式碼 (3) 接著會新增至您的 Visual Studio 方案 (4)。</span><span class="sxs-lookup"><span data-stu-id="bae24-136">The required changes are passed to the code generator to build the required migration code (3) which is then added to your Visual Studio solution (4).</span></span>

<span data-ttu-id="bae24-137">除了儲存在主要程式碼檔案的實際移轉程式碼，移轉也會產生一些額外的程式碼後置檔案。</span><span class="sxs-lookup"><span data-stu-id="bae24-137">In addition to the actual migration code that is stored in the main code file, migrations also generates some additional code-behind files.</span></span> <span data-ttu-id="bae24-138">這些檔案是藉由移轉使用的中繼資料，且不應該編輯的項目。</span><span class="sxs-lookup"><span data-stu-id="bae24-138">These files are metadata that is used by migrations and are not something you should edit.</span></span> <span data-ttu-id="bae24-139">其中一個檔案是資源檔 (.resx)，其中包含模型的快照集時所產生的移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-139">One of these files is a resource file (.resx) that contains a snapshot of the model at the time the migration was generated.</span></span> <span data-ttu-id="bae24-140">您會看到此介面用於下一個步驟。</span><span class="sxs-lookup"><span data-stu-id="bae24-140">You’ll see how this is used in the next step.</span></span>

<span data-ttu-id="bae24-141">此時您可能會執行**Update-database**以將變更套用到資料庫，然後就實作您的應用程式的其他區域。</span><span class="sxs-lookup"><span data-stu-id="bae24-141">At this point you would probably run **Update-Database** to apply your changes to the database, and then go about implementing other areas of your application.</span></span>

### <a name="subsequent-migrations"></a><span data-ttu-id="bae24-142">後續的移轉</span><span class="sxs-lookup"><span data-stu-id="bae24-142">Subsequent migrations</span></span>

<span data-ttu-id="bae24-143">稍後再回來，並對您的模型進行一些變更 – 在我們的範例中我們將新增**Url**屬性設**部落格**。</span><span class="sxs-lookup"><span data-stu-id="bae24-143">Later you come back and make some changes to your model – in our example we’ll add a **Url** property to **Blog**.</span></span> <span data-ttu-id="bae24-144">例如您想再發出命令**Add-migration AddUrl**若要建立要套用對應的資料庫移轉的結構變更。</span><span class="sxs-lookup"><span data-stu-id="bae24-144">You would then issue a command such as **Add-Migration AddUrl** to scaffold a migration to apply the corresponding database changes.</span></span> <span data-ttu-id="bae24-145">下圖是此命令會執行的高層級步驟。</span><span class="sxs-lookup"><span data-stu-id="bae24-145">The high level steps that this command performs are pictured below.</span></span>

![第二次移轉](~/ef6/media/secondmigration.png)

<span data-ttu-id="bae24-147">如同過去的時間，目前的模型會計算從程式碼 (1)。</span><span class="sxs-lookup"><span data-stu-id="bae24-147">Just like last time, the current model is calculated from code (1).</span></span> <span data-ttu-id="bae24-148">不過，這次有現有的移轉因此先前的模型會從最新的移轉 (2)。</span><span class="sxs-lookup"><span data-stu-id="bae24-148">However, this time there are existing migrations so the previous model is retrieved from the latest migration (2).</span></span> <span data-ttu-id="bae24-149">這兩種模型是 diffed 以尋找所需的資料庫變更 (3)，然後在程序完成之前一樣。</span><span class="sxs-lookup"><span data-stu-id="bae24-149">These two models are diffed to find the required database changes (3) and then the process completes as before.</span></span>

<span data-ttu-id="bae24-150">同樣的程序可用於任何進一步的移轉，您將新增至專案。</span><span class="sxs-lookup"><span data-stu-id="bae24-150">This same process is used for any further migrations that you add to the project.</span></span>

### <a name="why-bother-with-the-model-snapshot"></a><span data-ttu-id="bae24-151">為何要麻煩使用模型快照集嗎？</span><span class="sxs-lookup"><span data-stu-id="bae24-151">Why bother with the model snapshot?</span></span>

<span data-ttu-id="bae24-152">您可能想知道為什麼 EF 模型快照集 – 困擾之處的原因不只是查看資料庫。</span><span class="sxs-lookup"><span data-stu-id="bae24-152">You may be wondering why EF bothers with the model snapshot – why not just look at the database.</span></span> <span data-ttu-id="bae24-153">若是如此，閱讀。</span><span class="sxs-lookup"><span data-stu-id="bae24-153">If so, read on.</span></span> <span data-ttu-id="bae24-154">如果您不想再則可以略過本節。</span><span class="sxs-lookup"><span data-stu-id="bae24-154">If you’re not interested then you can skip this section.</span></span>

<span data-ttu-id="bae24-155">有數種 EF 會保留模型快照集前後的原因：</span><span class="sxs-lookup"><span data-stu-id="bae24-155">There are a number of reasons EF keeps the model snapshot around:</span></span>

-   <span data-ttu-id="bae24-156">它可讓您的資料庫偏離 EF 模型。</span><span class="sxs-lookup"><span data-stu-id="bae24-156">It allows your database to drift from the EF model.</span></span> <span data-ttu-id="bae24-157">可以直接在資料庫中，進行這些變更，或者您可以變更的 scaffold 程式碼中您的移轉，以進行變更。</span><span class="sxs-lookup"><span data-stu-id="bae24-157">These changes can be made directly in the database, or you can change the scaffolded code in your migrations to make the changes.</span></span> <span data-ttu-id="bae24-158">以下是幾個實際上這其中的範例：</span><span class="sxs-lookup"><span data-stu-id="bae24-158">Here are a couple of examples of this in practice:</span></span>
    -   <span data-ttu-id="bae24-159">您想要加入至一或多個資料表的資料行中的插入和更新，但您不想要 EF 模型中包含這些資料行。</span><span class="sxs-lookup"><span data-stu-id="bae24-159">You want to add an Inserted and Updated to column to one or more of your tables but you don’t want to include these columns in the EF model.</span></span> <span data-ttu-id="bae24-160">如果移轉會查看資料庫就會持續嘗試卸除這些資料行，每次您包含 scaffold 的移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-160">If migrations looked at the database it would continually try to drop these columns every time you scaffolded a migration.</span></span> <span data-ttu-id="bae24-161">使用模型的快照，EF 會只會偵測模型的合法變更。</span><span class="sxs-lookup"><span data-stu-id="bae24-161">Using the model snapshot, EF will only ever detect legitimate changes to the model.</span></span>
    -   <span data-ttu-id="bae24-162">您想要變更用於更新，以包含一些記錄的預存程序的主體。</span><span class="sxs-lookup"><span data-stu-id="bae24-162">You want to change the body of a stored procedure used for updates to include some logging.</span></span> <span data-ttu-id="bae24-163">如果移轉的資料庫中查看這個預存程序會持續嘗試它重設回 EF 必須要有的定義。</span><span class="sxs-lookup"><span data-stu-id="bae24-163">If migrations looked at this stored procedure from the database it would continually try and reset it back to the definition that EF expects.</span></span> <span data-ttu-id="bae24-164">藉由使用模型快照集，EF 將只會 scaffold 程式碼，以改變預存程序，當您變更 EF 模型中的程序的圖形。</span><span class="sxs-lookup"><span data-stu-id="bae24-164">By using the model snapshot, EF will only ever scaffold code to alter the stored procedure when you change the shape of the procedure in the EF model.</span></span>
    -   <span data-ttu-id="bae24-165">這些相同的原則套用至加入額外的索引，包括您的資料庫中的額外的資料表將 EF 對應至資料表、 等位的資料庫檢視。</span><span class="sxs-lookup"><span data-stu-id="bae24-165">These same principles apply to adding extra indexes, including extra tables in your database, mapping EF to a database view that sits over a table, etc.</span></span>
-   <span data-ttu-id="bae24-166">EF 模型包含多個只是資料庫的圖形。</span><span class="sxs-lookup"><span data-stu-id="bae24-166">The EF model contains more than just the shape of the database.</span></span> <span data-ttu-id="bae24-167">將整個模型，可以讓移轉，以查看您的模型和它們如何對應到資料行和資料表中的類別與屬性相關的資訊。</span><span class="sxs-lookup"><span data-stu-id="bae24-167">Having the entire model allows migrations to look at information about the properties and classes in your model and how they map to the columns and tables.</span></span> <span data-ttu-id="bae24-168">這項資訊可讓移轉至會在程式碼中，它則更有智慧。</span><span class="sxs-lookup"><span data-stu-id="bae24-168">This information allows migrations to be more intelligent in the code that it scaffolds.</span></span> <span data-ttu-id="bae24-169">比方說，如果您變更的屬性會對應至移轉的資料行名稱可以偵測到重新命名所看到，它是相同屬性 – 如果您只需要資料庫結構描述無法完成的項目。</span><span class="sxs-lookup"><span data-stu-id="bae24-169">For example, if you change the name of the column that a property maps to migrations can detect the rename by seeing that it’s the same property – something that can’t be done if you only have the database schema.</span></span> 

## <a name="what-causes-issues-in-team-environments"></a><span data-ttu-id="bae24-170">什麼會導致在小組環境中的問題</span><span class="sxs-lookup"><span data-stu-id="bae24-170">What causes issues in team environments</span></span>

<span data-ttu-id="bae24-171">當您的應用程式上工作的單一開發人員工作流程會涵蓋前一區段搭配好用。</span><span class="sxs-lookup"><span data-stu-id="bae24-171">The workflow covered in the previous section works great when you are a single developer working on an application.</span></span> <span data-ttu-id="bae24-172">它也非常適合小組環境如果您是唯一的人，對模型進行變更。</span><span class="sxs-lookup"><span data-stu-id="bae24-172">It also works well in a team environment if you are the only person making changes to the model.</span></span> <span data-ttu-id="bae24-173">在此案例中，您可以變更模型，產生移轉並將它們提交到您的原始檔控制。</span><span class="sxs-lookup"><span data-stu-id="bae24-173">In this scenario you can make model changes, generate migrations and submit them to your source control.</span></span> <span data-ttu-id="bae24-174">其他開發人員可以同步處理您的變更，並執行**Update-database**將套用的結構描述變更。</span><span class="sxs-lookup"><span data-stu-id="bae24-174">Other developers can sync your changes and run **Update-Database** to have the schema changes applied.</span></span>

<span data-ttu-id="bae24-175">問題開始時有多個開發人員對 EF 模型中的變更，並提交至原始檔控制在同一時間發生。</span><span class="sxs-lookup"><span data-stu-id="bae24-175">Issues start to arise when you have multiple developers making changes to the EF model and submitting to source control at the same time.</span></span> <span data-ttu-id="bae24-176">EF 的缺少是合併本機進行另一個開發人員已提交至原始檔控制，因為您上次同步處理時間的移轉作業移轉的第一個類別方法。</span><span class="sxs-lookup"><span data-stu-id="bae24-176">What EF lacks is a first class way to merge your local migrations with migrations that another developer has submitted to source control since you last synced.</span></span>

## <a name="an-example-of-a-merge-conflict"></a><span data-ttu-id="bae24-177">合併衝突的範例</span><span class="sxs-lookup"><span data-stu-id="bae24-177">An example of a merge conflict</span></span>

<span data-ttu-id="bae24-178">第一個讓我們看看這類的合併衝突的具體範例。</span><span class="sxs-lookup"><span data-stu-id="bae24-178">First let’s look at a concrete example of such a merge conflict.</span></span> <span data-ttu-id="bae24-179">我們會繼續進行我們稍早討論過的範例。</span><span class="sxs-lookup"><span data-stu-id="bae24-179">We’ll continue on with the example we looked at earlier.</span></span> <span data-ttu-id="bae24-180">做為開始點讓我們假設來自上一節的變更已簽入原始開發人員。</span><span class="sxs-lookup"><span data-stu-id="bae24-180">As a starting point let’s assume the changes from the previous section were checked in by the original developer.</span></span> <span data-ttu-id="bae24-181">當他們對變更的程式碼基底，我們會追蹤兩位開發人員。</span><span class="sxs-lookup"><span data-stu-id="bae24-181">We’ll track two developers as they make changes to code base.</span></span>

<span data-ttu-id="bae24-182">我們會將追蹤 EF 模型，並透過一些變更的移轉作業。</span><span class="sxs-lookup"><span data-stu-id="bae24-182">We’ll track the EF model and the migrations thru a number of changes.</span></span> <span data-ttu-id="bae24-183">起始點，這兩個開發人員有同步處理至原始檔控制儲存機制，如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="bae24-183">For a starting point, both developers have synced to the source control repository, as depicted in the following graphic.</span></span>

![起點](~/ef6/media/startingpoint.png)

<span data-ttu-id="bae24-185">開發人員\#1 和開發人員\#2 現在會對 EF 模型，在其本機程式碼基底。</span><span class="sxs-lookup"><span data-stu-id="bae24-185">Developer \#1 and developer \#2 now makes some changes to the EF model in their local code base.</span></span> <span data-ttu-id="bae24-186">開發人員\#1 多**分級**屬性設**部落格**– 並產生**AddRating**將變更套用至資料庫的移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-186">Developer \#1 adds a **Rating** property to **Blog** – and generates an **AddRating** migration to apply the changes to the database.</span></span> <span data-ttu-id="bae24-187">開發人員\#2 加入**讀者**屬性設**部落格**– 並產生對應**AddReaders**移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-187">Developer \#2 adds a **Readers** property to **Blog** – and generates the corresponding **AddReaders** migration.</span></span> <span data-ttu-id="bae24-188">這兩個開發人員執行**Update-database**以將變更套用至本機資料庫，然後再繼續開發應用程式。</span><span class="sxs-lookup"><span data-stu-id="bae24-188">Both developers run **Update-Database**, to apply the changes to their local databases, and then continue developing the application.</span></span>

> [!NOTE]
> <span data-ttu-id="bae24-189">移轉前面會加上時間戳記，因此我們的圖形表示，開發人員 AddReaders 遷移\#2 AddRating 移轉後來自開發人員\#1。</span><span class="sxs-lookup"><span data-stu-id="bae24-189">Migrations are prefixed with a timestamp, so our graphic represents that the AddReaders migration from Developer \#2 comes after the AddRating migration from Developer \#1.</span></span> <span data-ttu-id="bae24-190">是否開發人員\#1 或\#2 產生移轉的第一個會在一個小組或合併它們，我們將探討下一節中的程序中的問題並沒有差別。</span><span class="sxs-lookup"><span data-stu-id="bae24-190">Whether developer \#1 or \#2 generated the migration first makes no difference to the issues of working in a team, or the process for merging them that we’ll look at in the next section.</span></span>

![本機變更](~/ef6/media/localchanges.png)

<span data-ttu-id="bae24-192">很幸運了開發人員每天\#1，進而將其變更送出第一次。</span><span class="sxs-lookup"><span data-stu-id="bae24-192">It’s a lucky day for Developer \#1 as they happen to submit their changes first.</span></span> <span data-ttu-id="bae24-193">因為沒有其他人已簽入，因為它們同步處理其儲存機制，他們可以只提交其變更，而不執行任何合併。</span><span class="sxs-lookup"><span data-stu-id="bae24-193">Because no one else has checked in since they synced their repository, they can just submit their changes without performing any merging.</span></span>

![提交](~/ef6/media/submit.png)

<span data-ttu-id="bae24-195">現在是時候讓開發人員\#提交 2。</span><span class="sxs-lookup"><span data-stu-id="bae24-195">Now it’s time for Developer \#2 to submit.</span></span> <span data-ttu-id="bae24-196">它們不那麼幸運了。</span><span class="sxs-lookup"><span data-stu-id="bae24-196">They aren’t so lucky.</span></span> <span data-ttu-id="bae24-197">因為其他人已送出變更，因為它們同步處理，他們必須提取變更 」 和 「 合併。</span><span class="sxs-lookup"><span data-stu-id="bae24-197">Because someone else has submitted changes since they synced, they will need to pull down the changes and merge.</span></span> <span data-ttu-id="bae24-198">原始檔控制系統可能會無法自動合併程式碼層級的變更，因為它們是非常簡單。</span><span class="sxs-lookup"><span data-stu-id="bae24-198">The source control system will likely be able to automatically merge the changes at the code level since they are very simple.</span></span> <span data-ttu-id="bae24-199">開發人員的狀態\#2 的本機儲存機制之後會在下圖中所描述之同步處理。</span><span class="sxs-lookup"><span data-stu-id="bae24-199">The state of Developer \#2’s local repository after syncing is depicted in the following graphic.</span></span> 

![提取](~/ef6/media/pull.png)

<span data-ttu-id="bae24-201">在此階段的開發人員\#2 可以執行**Update-database**其會偵測新**AddRating**移轉 (開發人員尚未套用的\#2 的資料庫) 並將它套用。</span><span class="sxs-lookup"><span data-stu-id="bae24-201">At this stage Developer \#2 can run **Update-Database** which will detect the new **AddRating** migration (which hasn’t been applied to Developer \#2’s database) and apply it.</span></span> <span data-ttu-id="bae24-202">現在**分級**資料行加入至**部落格**資料表和資料庫會與模型同步。</span><span class="sxs-lookup"><span data-stu-id="bae24-202">Now the **Rating** column is added to the **Blogs** table and the database is in sync with the model.</span></span>

<span data-ttu-id="bae24-203">不過有幾個問題：</span><span class="sxs-lookup"><span data-stu-id="bae24-203">There are a couple of problems though:</span></span>

1.  <span data-ttu-id="bae24-204">雖然**Update-database**收取**AddRating**移轉，它也會引發警告：*無法更新資料庫，以符合目前的模型，因為有暫止的變更和已停用自動移轉...*</span><span class="sxs-lookup"><span data-stu-id="bae24-204">Although **Update-Database** will apply the **AddRating** migration it will also raise a warning: *Unable to update database to match the current model because there are pending changes and automatic migration is disabled…*</span></span>
    <span data-ttu-id="bae24-205">問題是模型快照集儲存在最後一個移轉 (**AddReader**) 遺漏**評等**屬性**部落格**(因為它不是模型的一部分時移轉所產生）。</span><span class="sxs-lookup"><span data-stu-id="bae24-205">The problem is that the model snapshot stored in the last migration (**AddReader**) is missing the **Rating** property on **Blog** (since it wasn’t part of the model when the migration was generated).</span></span> <span data-ttu-id="bae24-206">程式碼第一次偵測到不符合目前的模型中的最後一個移轉的模型，並會引發警告。</span><span class="sxs-lookup"><span data-stu-id="bae24-206">Code First detects that the model in the last migration doesn’t match the current model and raises the warning.</span></span>
2.  <span data-ttu-id="bae24-207">執行應用程式時，會導致 InvalidOperationException，指出 「*備份 '為 [bloggingcontext]' 內容的模型已變更，因為所建立的資料庫。請考慮使用 Code First 移轉更新資料庫...」*</span><span class="sxs-lookup"><span data-stu-id="bae24-207">Running the application would result in an InvalidOperationException stating that “*The model backing the 'BloggingContext' context has changed since the database was created. Consider using Code First Migrations to update the database…”*</span></span>
    <span data-ttu-id="bae24-208">同樣地，問題是儲存在最後一個移轉模型快照集不符合目前的模型。</span><span class="sxs-lookup"><span data-stu-id="bae24-208">Again, the problem is the model snapshot stored in the last migration doesn’t match the current model.</span></span>
3.  <span data-ttu-id="bae24-209">最後，我們會預期執行**Add-migration**現在會產生空白的移轉 （因為沒有任何變更將套用至資料庫）。</span><span class="sxs-lookup"><span data-stu-id="bae24-209">Finally, we would expect running **Add-Migration** now would generate an empty migration (since there are no changes to apply to the database).</span></span> <span data-ttu-id="bae24-210">但是因為移轉成一個最後的移轉會比較目前的模型 (這是遺漏**評等**屬性) 它實際上會建立另一個**AddColumn**呼叫增益集**評等**資料行。</span><span class="sxs-lookup"><span data-stu-id="bae24-210">But because migrations compares the current model to the one from the last migration (which is missing the **Rating** property) it will actually scaffold another **AddColumn** call to add in the **Rating** column.</span></span> <span data-ttu-id="bae24-211">當然，這項移轉將會失敗期間**Update-database**因為**分級**資料行已經存在。</span><span class="sxs-lookup"><span data-stu-id="bae24-211">Of course, this migration would fail during **Update-Database** because the **Rating** column already exists.</span></span>

## <a name="resolving-the-merge-conflict"></a><span data-ttu-id="bae24-212">解決合併衝突</span><span class="sxs-lookup"><span data-stu-id="bae24-212">Resolving the merge conflict</span></span>

<span data-ttu-id="bae24-213">好消息是它不太難手動 – 處理合併提供您已了解移轉的運作方式。</span><span class="sxs-lookup"><span data-stu-id="bae24-213">The good news is that it’s not too hard to deal with the merge manually – provided you have an understanding of how migrations works.</span></span> <span data-ttu-id="bae24-214">因此，如果您已直接跳至本節...</span><span class="sxs-lookup"><span data-stu-id="bae24-214">So if you’ve skipped ahead to this section…</span></span> <span data-ttu-id="bae24-215">很抱歉，您需要返回並先閱讀本文的其餘部分 ！</span><span class="sxs-lookup"><span data-stu-id="bae24-215">sorry, you need to go back and read the rest of the article first!</span></span>

<span data-ttu-id="bae24-216">有兩個選項，最簡單的方法是產生空白的移轉具有正確的目前模型當做快照集。</span><span class="sxs-lookup"><span data-stu-id="bae24-216">There are two options, the easiest is to generate a blank migration that has the correct current model as a snapshot.</span></span> <span data-ttu-id="bae24-217">第二個選項是，更新中有正確的最後一個移轉的快照集模型的快照集。</span><span class="sxs-lookup"><span data-stu-id="bae24-217">The second option is to update the snapshot in the last migration to have the correct model snapshot.</span></span> <span data-ttu-id="bae24-218">第二個選項是有點困難，也不能在每個案例中，但這也是簡潔因為不需要用到新增額外的移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-218">The second option is a little harder and can’t be used in every scenario, but it’s also cleaner because it doesn’t involve adding an extra migration.</span></span>

### <a name="option-1-add-a-blank-merge-migration"></a><span data-ttu-id="bae24-219">選項 1： 新增空白的 'merge' 移轉</span><span class="sxs-lookup"><span data-stu-id="bae24-219">Option 1: Add a blank ‘merge’ migration</span></span>

<span data-ttu-id="bae24-220">我們產生空白的移轉，專門用來確保最新的移轉有這個選項在正確的模型快照集儲存在其中。</span><span class="sxs-lookup"><span data-stu-id="bae24-220">In this option we generate a blank migration solely for the purpose of making sure the latest migration has the correct model snapshot stored in it.</span></span>

<span data-ttu-id="bae24-221">此選項可用來不論使用者產生的最後一個移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-221">This option can be used regardless of who generated the last migration.</span></span> <span data-ttu-id="bae24-222">在範例中我們已依照程式開發人員\#2 會處理合併和其發生產生的最後一個移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-222">In the example we’ve been following Developer \#2 is taking care of the merge and they happened to generate the last migration.</span></span> <span data-ttu-id="bae24-223">如果可以使用這些相同的步驟，但開發人員\#1 產生的最後一個移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-223">But these same steps can be used if Developer \#1 generated the last migration.</span></span> <span data-ttu-id="bae24-224">如果有相關的多個移轉 – 我們只探討了兩個為了簡單起見，步驟也適用。</span><span class="sxs-lookup"><span data-stu-id="bae24-224">The steps also apply if there are multiple migrations involved – we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="bae24-225">下列程序可用於這種方法，從您發現您已變更，需要從原始檔控制進行同步處理的時間。</span><span class="sxs-lookup"><span data-stu-id="bae24-225">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="bae24-226">請確定移轉已寫入任何暫止中的模型變更您的本機程式碼基底。</span><span class="sxs-lookup"><span data-stu-id="bae24-226">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="bae24-227">這個步驟可確保產生空白的移轉時，千萬別錯過任何合法的變更。</span><span class="sxs-lookup"><span data-stu-id="bae24-227">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="bae24-228">與原始檔控制同步處理。</span><span class="sxs-lookup"><span data-stu-id="bae24-228">Sync with source control.</span></span>
3.  <span data-ttu-id="bae24-229">執行**Update-database**套用任何其他開發人員簽入的新移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-229">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="bae24-230">\*\*
    *注意: \* \* \* 若您未獲得 Update-database 命令中的任何警告，則沒有任何新的移轉，從其他開發人員與不需要執行任何進一步合併。*</span><span class="sxs-lookup"><span data-stu-id="bae24-230">\*\*
*Note:\*\*\*\*if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="bae24-231">執行**Add-migration&lt;挑選\_\_名稱&gt;– IgnoreChanges** (例如**Add-migration 合併 – IgnoreChanges**)。</span><span class="sxs-lookup"><span data-stu-id="bae24-231">Run **Add-Migration &lt;pick\_a\_name&gt; –IgnoreChanges** (for example, **Add-Migration Merge –IgnoreChanges**).</span></span> <span data-ttu-id="bae24-232">這會產生與 （包括目前模型的快照集） 的所有中繼資料的移轉，但會忽略比較在最後一個移轉中的快照集的最新模型時，偵測到的任何變更 (這表示您取得空白**向上**和**往下**方法)。</span><span class="sxs-lookup"><span data-stu-id="bae24-232">This generates a migration with all the metadata (including a snapshot of the current model) but will ignore any changes it detects when comparing the current model to the snapshot in the last migrations (meaning you get a blank **Up** and **Down** method).</span></span>
5.  <span data-ttu-id="bae24-233">繼續開發，或提交至原始檔控制 （之後執行單元測試當然）。</span><span class="sxs-lookup"><span data-stu-id="bae24-233">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="bae24-234">以下是開發人員的狀態\#2 的本機程式碼基底之後使用這種方法。</span><span class="sxs-lookup"><span data-stu-id="bae24-234">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![合併移轉](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a><span data-ttu-id="bae24-236">選項 2： 更新模型中的快照集的最後一個移轉</span><span class="sxs-lookup"><span data-stu-id="bae24-236">Option 2: Update the model snapshot in the last migration</span></span>

<span data-ttu-id="bae24-237">此選項非常類似於選項 1，但因為移除額外的空白的移轉 – 讓我們面對現實吧，想在其解決方案的額外的程式碼檔案。</span><span class="sxs-lookup"><span data-stu-id="bae24-237">This option is very similar to option 1 but removes the extra blank migration – because let’s face it, who wants extra code files in their solution.</span></span>

<span data-ttu-id="bae24-238">**這個方法才可行，如果最新的移轉只存在於您的本機程式碼基底，且有尚未傳送至原始檔控制 （例如，如果最後一個移轉由使用者執行合併產生）**。</span><span class="sxs-lookup"><span data-stu-id="bae24-238">**This approach is only feasible if the latest migration exists only in your local code base and has not yet been submitted to source control (for example, if the last migration was generated by the user doing the merge)**.</span></span> <span data-ttu-id="bae24-239">編輯中繼資料的移轉作業的其他開發人員可能已經套用到其開發資料庫 – 或甚至更糟的是套用至實際執行資料庫 – 可能會導致未預期的副作用。</span><span class="sxs-lookup"><span data-stu-id="bae24-239">Editing the metadata of migrations that other developers may have already applied to their development database – or even worse applied to a production database – can result in unexpected side effects.</span></span> <span data-ttu-id="bae24-240">在程序期間我們要在本機資料庫中復原的最後一個移轉，並重新將它套用更新的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="bae24-240">During the process we’re going to roll back the last migration in our local database and re-apply it with updated metadata.</span></span>

<span data-ttu-id="bae24-241">雖然最後一個移轉必須只會在本機的程式碼基底的數目或繼續它的移轉的順序沒有限制。</span><span class="sxs-lookup"><span data-stu-id="bae24-241">While the last migration needs to just be in the local code base there are no restrictions to the number or order of migrations that proceed it.</span></span> <span data-ttu-id="bae24-242">可以有多個移轉，從多個不同的開發人員和相同的步驟適用於 – 我們只探討了兩個以保持簡單。</span><span class="sxs-lookup"><span data-stu-id="bae24-242">There can be multiple migrations from multiple different developers and the same steps apply– we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="bae24-243">下列程序可用於這種方法，從您發現您已變更，需要從原始檔控制進行同步處理的時間。</span><span class="sxs-lookup"><span data-stu-id="bae24-243">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="bae24-244">請確定移轉已寫入任何暫止中的模型變更您的本機程式碼基底。</span><span class="sxs-lookup"><span data-stu-id="bae24-244">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="bae24-245">這個步驟可確保產生空白的移轉時，千萬別錯過任何合法的變更。</span><span class="sxs-lookup"><span data-stu-id="bae24-245">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="bae24-246">與原始檔控制同步處理。</span><span class="sxs-lookup"><span data-stu-id="bae24-246">Sync with the source control.</span></span>
3.  <span data-ttu-id="bae24-247">執行**Update-database**套用任何其他開發人員簽入的新移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-247">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="bae24-248">\*\*
    *注意: \* \* \* 若您未獲得 Update-database 命令中的任何警告，則沒有任何新的移轉，從其他開發人員與不需要執行任何進一步合併。*</span><span class="sxs-lookup"><span data-stu-id="bae24-248">\*\*
*Note:\*\*\*\*if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="bae24-249">執行**Update-database – TargetMigration&lt;第二個\_上次\_移轉&gt;** (我們已經後面的範例中，這會是**Update-database –TargetMigration AddRating**)。</span><span class="sxs-lookup"><span data-stu-id="bae24-249">Run **Update-Database –TargetMigration &lt;second\_last\_migration&gt;** (in the example we’ve been following this would be **Update-Database –TargetMigration AddRating**).</span></span> <span data-ttu-id="bae24-250">這個資料庫回到第二個狀態的角色最後一個移轉 – 實際上 '無法套用' 資料庫中的最後一個移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-250">This roles the database back to the state of the second last migration – effectively ‘un-applying’ the last migration from the database.</span></span>
    <span data-ttu-id="bae24-251">\*\*
    *注意: \* \* \* 此步驟，才能讓它編輯移轉作業的中繼資料，因為中繼資料也會儲存在安全\_ \_MigrationsHistoryTable 的資料庫。這就是為什麼當最後一個移轉只能在您本機的程式碼基底中，您應該只使用此選項。如果其他資料庫已套用最後一個移轉您也必須加以復原並重新套用更新的中繼資料的最後一個移轉。*</span><span class="sxs-lookup"><span data-stu-id="bae24-251">\*\*
*Note:\*\*\*\*This step is required to make it safe to edit the metadata of the migration since the metadata is also stored in the \_\_MigrationsHistoryTable of the database. This is why you should only use this option if the last migration is only in your local code base. If other databases had the last migration applied you would also have to roll them back and re-apply the last migration to update the metadata.*</span></span> 
5.  <span data-ttu-id="bae24-252">執行**Add-migration&lt;完整\_名稱\_包括\_時間戳記\_的\_上次\_移轉**&gt; （在範例我們已遵循這看起來應該像**Add-migration 201311062215252\_AddReaders**)。</span><span class="sxs-lookup"><span data-stu-id="bae24-252">Run **Add-Migration &lt;full\_name\_including\_timestamp\_of\_last\_migration**&gt; (in the example we’ve been following this would be something like **Add-Migration 201311062215252\_AddReaders**).</span></span>
    <span data-ttu-id="bae24-253">\*\*
    *注意: \* \* \* 您需要包含時間戳記，如此便能移轉可讓您知道您想要編輯現有的移轉，而不是一個新的 scaffolding。*</span><span class="sxs-lookup"><span data-stu-id="bae24-253">\*\*
    *Note:\*\*\*\*You need to include the timestamp so that migrations knows you want to edit the existing migration rather than scaffolding a new one.*</span></span>
<span data-ttu-id="bae24-254">這會更新以符合目前模型的最後一個移轉的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="bae24-254">This will update the metadata for the last migration to match the current model.</span></span> <span data-ttu-id="bae24-255">當命令完成，但這正是您想要您會收到下列警告。</span><span class="sxs-lookup"><span data-stu-id="bae24-255">You’ll get the following warning when the command completes, but that’s exactly what you want.</span></span> <span data-ttu-id="bae24-256">「*只有設計工具的程式碼移轉 ' 201311062215252\_AddReaders' 已重新建構。若要重新建立整個移轉的結構，請使用-Force 參數。 」*</span><span class="sxs-lookup"><span data-stu-id="bae24-256">“*Only the Designer Code for migration '201311062215252\_AddReaders' was re-scaffolded. To re-scaffold the entire migration, use the -Force parameter.”*</span></span>
6.  <span data-ttu-id="bae24-257">執行**Update-database**來重新套用最新的移轉與更新的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="bae24-257">Run **Update-Database** to re-apply the latest migration with the updated metadata.</span></span>
7.  <span data-ttu-id="bae24-258">繼續開發，或提交至原始檔控制 （之後執行單元測試當然）。</span><span class="sxs-lookup"><span data-stu-id="bae24-258">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="bae24-259">以下是開發人員的狀態\#2 的本機程式碼基底之後使用這種方法。</span><span class="sxs-lookup"><span data-stu-id="bae24-259">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![更新的中繼資料](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a><span data-ttu-id="bae24-261">總結</span><span class="sxs-lookup"><span data-stu-id="bae24-261">Summary</span></span>

<span data-ttu-id="bae24-262">在小組環境中使用 Code First 移轉時，有一些挑戰。</span><span class="sxs-lookup"><span data-stu-id="bae24-262">There are some challenges when using Code First Migrations in a team environment.</span></span> <span data-ttu-id="bae24-263">不過，移轉的運作方式，以及一些簡單的方法，來解決合併衝突的基本了解讓您輕鬆克服這些挑戰。</span><span class="sxs-lookup"><span data-stu-id="bae24-263">However, a basic understanding of how migrations works and some simple approaches for resolving merge conflicts make it easy to overcome these challenges.</span></span>

<span data-ttu-id="bae24-264">基本的問題是不正確的中繼資料儲存在最新的移轉。</span><span class="sxs-lookup"><span data-stu-id="bae24-264">The fundamental issue is incorrect metadata stored in the latest migration.</span></span> <span data-ttu-id="bae24-265">這會導致程式碼第一次不正確地偵測 不符合目前的模型和資料庫結構描述，以及建立不正確的程式碼，在下一個移轉的結構。</span><span class="sxs-lookup"><span data-stu-id="bae24-265">This causes Code First to incorrectly detect that the current model and database schema don’t match and to scaffold incorrect code in the next migration.</span></span> <span data-ttu-id="bae24-266">可以克服這種情況下，藉由產生空白的移轉與正確的模型，或更新最新的移轉中的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="bae24-266">This situation can be overcome by generating a blank migration with the correct model, or updating the metadata in the latest migration.</span></span>
