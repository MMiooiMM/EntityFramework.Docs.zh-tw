---
title: 在小組環境-EF6 code First 移轉
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: 53460b6cdd454099ccf93b4e2133e4ea21278a64
ms.sourcegitcommit: fa863883f1193d2118c2f9cee90808baa5e3e73e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/04/2018
ms.locfileid: "52857464"
---
# <a name="code-first-migrations-in-team-environments"></a>在小組環境中的 code First 移轉
> [!NOTE]
> 本文假設您知道如何在基本案例中使用 Code First 移轉。 如果不這麼做，則您將需要閱讀[Code First 移轉](~/ef6/modeling/code-first/migrations/index.md)再繼續進行。

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a>喝杯咖啡，您必須閱讀這整篇文章

在小組環境中的問題是大部分周圍合併時兩位開發人員在其本機程式碼基底中產生移轉的移轉。 雖然要面對的這些步驟很簡單，它們需要您已充分了解移轉的運作方式。 請不要只請直接跳到結尾 – 花點時間閱讀整個的文章，以確保您成功。

## <a name="some-general-guidelines"></a>一些一般指導方針

我們深入探討如何管理合併多個開發人員所產生的移轉之前，以下是一些一般指導方針來設定您準備好邁向成功。

### <a name="each-team-member-should-have-a-local-development-database"></a>每個小組成員應該具有本機開發資料庫

移轉會使用 **\_ \_MigrationsHistory**儲存哪些移轉已套用至資料庫資料表。 如果您有多個開發人員嘗試以相同的資料庫為目標時產生不同的移轉 (並因此分享 **\_ \_MigrationsHistory**資料表) 移轉前往亂成一團了。

當然，如果您的小組成員不會產生移轉，是讓它們共用中央開發資料庫沒有問題。

### <a name="avoid-automatic-migrations"></a>避免自動移轉

重點是，自動移轉一開始看起來沒有問題，在小組環境中，但實際上只是不會使用。 如果您想要知道為什麼，繼續閱讀 – 如果沒有，則您可以跳到下一節。

自動移轉，可讓您有資料庫結構描述更新，以符合目前的模型，而不需要產生程式碼檔案 （程式碼型的移轉）。 在小組環境中，如果您只會使用它們，並永遠不會產生任何程式碼為基礎的移轉自動移轉會非常正常運作。 問題在於，自動移轉限制，且未處理的一些作業屬性/資料行重新命名、 將資料移到另一個資料表，等等。若要處理這些案例，您最後會產生程式碼型的移轉 （和編輯的 scaffold 程式碼） 的混合之間都由自動移轉的變更。 這對它幾乎不可能將變更合併，當兩位開發人員簽入移轉。

## <a name="screencasts"></a>螢幕錄製影片

如果您想而不是觀看螢幕錄製影片比閱讀這篇文章，下列兩個影片涵蓋這份文件相同的內容。

### <a name="video-one-migrations---under-the-hood"></a>影片的一個:"移轉-在幕後"

[這段螢幕錄製影片](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood)涵蓋如何移轉追蹤，並使用模型的相關資訊，來偵測模型變更。

### <a name="video-two-migrations---team-environments"></a>影片的兩個: 「 移轉-小組環境 」

在上一段影片中，從概念上建置[這段螢幕錄製影片](http://channel9.msdn.com/blogs/ef/migrations-team-environments)涵蓋了在小組環境，以及如何解決這些問題發生的問題。

## <a name="understanding-how-migrations-works"></a>了解移轉的運作方式

要成功地在小組環境中使用移轉的索引鍵是基本了解如何移轉追蹤，並使用有關模型的資訊來偵測模型的變更。

### <a name="the-first-migration"></a>第一次移轉

當您第一次移轉新增至您的專案時，您會執行類似**Add-migration 第一個**在套件管理員主控台。 下圖是此命令會執行的高層級步驟。

![第一次移轉](~/ef6/media/firstmigration.png)

目前的模型會計算從您的程式碼 (1)。 模型的差異 (2) 然後計算所需的資料庫物件，因為這是第一次移轉模型不同只會使用空的模型進行比較。 必要的變更會傳遞至程式碼產生器，以建置必要的移轉程式碼 (3) 接著會新增至您的 Visual Studio 方案 (4)。

除了儲存在主要程式碼檔案的實際移轉程式碼，移轉也會產生一些額外的程式碼後置檔案。 這些檔案是藉由移轉使用的中繼資料，且不應該編輯的項目。 其中一個檔案是資源檔 (.resx)，其中包含模型的快照集時所產生的移轉。 您會看到此介面用於下一個步驟。

此時您可能會執行**Update-database**以將變更套用到資料庫，然後就實作您的應用程式的其他區域。

### <a name="subsequent-migrations"></a>後續的移轉

稍後再回來，並對您的模型進行一些變更 – 在我們的範例中我們將新增**Url**屬性設**部落格**。 例如您想再發出命令**Add-migration AddUrl**若要建立要套用對應的資料庫移轉的結構變更。 下圖是此命令會執行的高層級步驟。

![第二次移轉](~/ef6/media/secondmigration.png)

如同過去的時間，目前的模型會計算從程式碼 (1)。 不過，這次有現有的移轉因此先前的模型會從最新的移轉 (2)。 這兩種模型是 diffed 以尋找所需的資料庫變更 (3)，然後在程序完成之前一樣。

同樣的程序可用於任何進一步的移轉，您將新增至專案。

### <a name="why-bother-with-the-model-snapshot"></a>為何要麻煩使用模型快照集嗎？

您可能想知道為什麼 EF 模型快照集 – 困擾之處的原因不只是查看資料庫。 若是如此，閱讀。 如果您不想再則可以略過本節。

有數種 EF 會保留模型快照集前後的原因：

-   它可讓您的資料庫偏離 EF 模型。 可以直接在資料庫中，進行這些變更，或者您可以變更的 scaffold 程式碼中您的移轉，以進行變更。 以下是幾個實際上這其中的範例：
    -   您想要加入至一或多個資料表的資料行中的插入和更新，但您不想要 EF 模型中包含這些資料行。 如果移轉會查看資料庫就會持續嘗試卸除這些資料行，每次您包含 scaffold 的移轉。 使用模型的快照，EF 會只會偵測模型的合法變更。
    -   您想要變更用於更新，以包含一些記錄的預存程序的主體。 如果移轉的資料庫中查看這個預存程序會持續嘗試它重設回 EF 必須要有的定義。 藉由使用模型快照集，EF 將只會 scaffold 程式碼，以改變預存程序，當您變更 EF 模型中的程序的圖形。
    -   這些相同的原則套用至加入額外的索引，包括您的資料庫中的額外的資料表將 EF 對應至資料表、 等位的資料庫檢視。
-   EF 模型包含多個只是資料庫的圖形。 將整個模型，可以讓移轉，以查看您的模型和它們如何對應到資料行和資料表中的類別與屬性相關的資訊。 這項資訊可讓移轉至會在程式碼中，它則更有智慧。 比方說，如果您變更的屬性會對應至移轉的資料行名稱可以偵測到重新命名所看到，它是相同屬性 – 如果您只需要資料庫結構描述無法完成的項目。 

## <a name="what-causes-issues-in-team-environments"></a>什麼會導致在小組環境中的問題

當您的應用程式上工作的單一開發人員工作流程會涵蓋前一區段搭配好用。 它也非常適合小組環境如果您是唯一的人，對模型進行變更。 在此案例中，您可以變更模型，產生移轉並將它們提交到您的原始檔控制。 其他開發人員可以同步處理您的變更，並執行**Update-database**將套用的結構描述變更。

問題開始時有多個開發人員對 EF 模型中的變更，並提交至原始檔控制在同一時間發生。 EF 的缺少是合併本機進行另一個開發人員已提交至原始檔控制，因為您上次同步處理時間的移轉作業移轉的第一個類別方法。

## <a name="an-example-of-a-merge-conflict"></a>合併衝突的範例

第一個讓我們看看這類的合併衝突的具體範例。 我們會繼續進行我們稍早討論過的範例。 做為開始點讓我們假設來自上一節的變更已簽入原始開發人員。 當他們對變更的程式碼基底，我們會追蹤兩位開發人員。

我們會將追蹤 EF 模型，並透過一些變更的移轉作業。 起始點，這兩個開發人員有同步處理至原始檔控制儲存機制，如下圖所示。

![起點](~/ef6/media/startingpoint.png)

開發人員\#1 和開發人員\#2 現在會對 EF 模型，在其本機程式碼基底。 開發人員\#1 多**分級**屬性設**部落格**– 並產生**AddRating**將變更套用至資料庫的移轉。 開發人員\#2 加入**讀者**屬性設**部落格**– 並產生對應**AddReaders**移轉。 這兩個開發人員執行**Update-database**以將變更套用至本機資料庫，然後再繼續開發應用程式。

> [!NOTE]
> 移轉前面會加上時間戳記，因此我們的圖形表示，開發人員 AddReaders 遷移\#2 AddRating 移轉後來自開發人員\#1。 是否開發人員\#1 或\#2 產生移轉的第一個會在一個小組或合併它們，我們將探討下一節中的程序中的問題並沒有差別。

![本機變更](~/ef6/media/localchanges.png)

很幸運了開發人員每天\#1，進而將其變更送出第一次。 因為沒有其他人已簽入，因為它們同步處理其儲存機制，他們可以只提交其變更，而不執行任何合併。

![提交](~/ef6/media/submit.png)

現在是時候讓開發人員\#提交 2。 它們不那麼幸運了。 因為其他人已送出變更，因為它們同步處理，他們必須提取變更 」 和 「 合併。 原始檔控制系統可能會無法自動合併程式碼層級的變更，因為它們是非常簡單。 開發人員的狀態\#2 的本機儲存機制之後會在下圖中所描述之同步處理。 

![提取](~/ef6/media/pull.png)

在此階段的開發人員\#2 可以執行**Update-database**其會偵測新**AddRating**移轉 (開發人員尚未套用的\#2 的資料庫) 並將它套用。 現在**分級**資料行加入至**部落格**資料表和資料庫會與模型同步。

不過有幾個問題：

1.  雖然**Update-database**收取**AddRating**移轉，它也會引發警告：*無法更新資料庫，以符合目前的模型，因為有暫止的變更和已停用自動移轉...*
    問題是模型快照集儲存在最後一個移轉 (**AddReader**) 遺漏**評等**屬性**部落格**(因為它不是模型的一部分時移轉所產生）。 程式碼第一次偵測到不符合目前的模型中的最後一個移轉的模型，並會引發警告。
2.  執行應用程式時，會導致 InvalidOperationException，指出 「*備份 '為 [bloggingcontext]' 內容的模型已變更，因為所建立的資料庫。請考慮使用 Code First 移轉更新資料庫...」*
    同樣地，問題是儲存在最後一個移轉模型快照集不符合目前的模型。
3.  最後，我們會預期執行**Add-migration**現在會產生空白的移轉 （因為沒有任何變更將套用至資料庫）。 但是因為移轉成一個最後的移轉會比較目前的模型 (這是遺漏**評等**屬性) 它實際上會建立另一個**AddColumn**呼叫增益集**評等**資料行。 當然，這項移轉將會失敗期間**Update-database**因為**分級**資料行已經存在。

## <a name="resolving-the-merge-conflict"></a>解決合併衝突

好消息是它不太難手動 – 處理合併提供您已了解移轉的運作方式。 因此，如果您已直接跳至本節... 很抱歉，您需要返回並先閱讀本文的其餘部分 ！

有兩個選項，最簡單的方法是產生空白的移轉具有正確的目前模型當做快照集。 第二個選項是，更新中有正確的最後一個移轉的快照集模型的快照集。 第二個選項是有點困難，也不能在每個案例中，但這也是簡潔因為不需要用到新增額外的移轉。

### <a name="option-1-add-a-blank-merge-migration"></a>選項 1： 新增空白的 'merge' 移轉

我們產生空白的移轉，專門用來確保最新的移轉有這個選項在正確的模型快照集儲存在其中。

此選項可用來不論使用者產生的最後一個移轉。 在範例中我們已依照程式開發人員\#2 會處理合併和其發生產生的最後一個移轉。 如果可以使用這些相同的步驟，但開發人員\#1 產生的最後一個移轉。 如果有相關的多個移轉 – 我們只探討了兩個為了簡單起見，步驟也適用。

下列程序可用於這種方法，從您發現您已變更，需要從原始檔控制進行同步處理的時間。

1.  請確定移轉已寫入任何暫止中的模型變更您的本機程式碼基底。 這個步驟可確保產生空白的移轉時，千萬別錯過任何合法的變更。
2.  與原始檔控制同步處理。
3.  執行**Update-database**套用任何其他開發人員簽入的新移轉。
    **_注意︰_**  *若您未獲得 Update-database 命令中的任何警告，則沒有任何新的移轉，從其他開發人員與不需要執行任何進一步合併。*
4.  執行**Add-migration&lt;挑選\_\_名稱&gt;– IgnoreChanges** (例如**Add-migration 合併 – IgnoreChanges**)。 這會產生與 （包括目前模型的快照集） 的所有中繼資料的移轉，但會忽略比較在最後一個移轉中的快照集的最新模型時，偵測到的任何變更 (這表示您取得空白**向上**和**往下**方法)。
5.  繼續開發，或提交至原始檔控制 （之後執行單元測試當然）。

以下是開發人員的狀態\#2 的本機程式碼基底之後使用這種方法。

![合併移轉](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a>選項 2： 更新模型中的快照集的最後一個移轉

此選項非常類似於選項 1，但因為移除額外的空白的移轉 – 讓我們面對現實吧，想在其解決方案的額外的程式碼檔案。

**這個方法才可行，如果最新的移轉只存在於您的本機程式碼基底，且有尚未傳送至原始檔控制 （例如，如果最後一個移轉由使用者執行合併產生）**。 編輯中繼資料的移轉作業的其他開發人員可能已經套用到其開發資料庫 – 或甚至更糟的是套用至實際執行資料庫 – 可能會導致未預期的副作用。 在程序期間我們要在本機資料庫中復原的最後一個移轉，並重新將它套用更新的中繼資料。

雖然最後一個移轉必須只會在本機的程式碼基底的數目或繼續它的移轉的順序沒有限制。 可以有多個移轉，從多個不同的開發人員和相同的步驟適用於 – 我們只探討了兩個以保持簡單。

下列程序可用於這種方法，從您發現您已變更，需要從原始檔控制進行同步處理的時間。

1.  請確定移轉已寫入任何暫止中的模型變更您的本機程式碼基底。 這個步驟可確保產生空白的移轉時，千萬別錯過任何合法的變更。
2.  與原始檔控制同步處理。
3.  執行**Update-database**套用任何其他開發人員簽入的新移轉。
    **_注意︰_**  *若您未獲得 Update-database 命令中的任何警告，則沒有任何新的移轉，從其他開發人員與不需要執行任何進一步合併。*
4.  執行**Update-database – TargetMigration&lt;第二個\_上次\_移轉&gt;** (我們已經後面的範例中，這會是**Update-database –TargetMigration AddRating**)。 這個資料庫回到第二個狀態的角色最後一個移轉 – 實際上 '無法套用' 資料庫中的最後一個移轉。
    **_注意︰_**  *這個步驟，才能進行編輯移轉作業的中繼資料，因為中繼資料也會儲存在安全\_ \_MigrationsHistoryTable 的資料庫。這就是為什麼當最後一個移轉只能在您本機的程式碼基底中，您應該只使用此選項。如果其他資料庫已套用最後一個移轉您也必須加以復原並重新套用更新的中繼資料的最後一個移轉。* 
5.  執行**Add-migration&lt;完整\_名稱\_包括\_時間戳記\_的\_上次\_移轉**&gt; （在範例我們已遵循這看起來應該像**Add-migration 201311062215252\_AddReaders**)。
    **_注意︰_**  *您需要包含時間戳記，如此便能移轉可讓您知道您想要編輯現有的移轉，而不是一個新的 scaffolding。*
    這會更新以符合目前模型的最後一個移轉的中繼資料。 當命令完成，但這正是您想要您會收到下列警告。 「*只有設計工具的程式碼移轉 ' 201311062215252\_AddReaders' 已重新建構。若要重新建立整個移轉的結構，請使用-Force 參數。 」*
6.  執行**Update-database**來重新套用最新的移轉與更新的中繼資料。
7.  繼續開發，或提交至原始檔控制 （之後執行單元測試當然）。

以下是開發人員的狀態\#2 的本機程式碼基底之後使用這種方法。

![更新的中繼資料](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a>總結

在小組環境中使用 Code First 移轉時，有一些挑戰。 不過，移轉的運作方式，以及一些簡單的方法，來解決合併衝突的基本了解讓您輕鬆克服這些挑戰。

基本的問題是不正確的中繼資料儲存在最新的移轉。 這會導致程式碼第一次不正確地偵測 不符合目前的模型和資料庫結構描述，以及建立不正確的程式碼，在下一個移轉的結構。 可以克服這種情況下，藉由產生空白的移轉與正確的模型，或更新最新的移轉中的中繼資料。
